<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Endless Jumper â€” Fixed</title>
<style>
  :root {
    --w: 480px;
    --h: 854px;
  }
  html, body {
    height: 100%;
    margin: 0;
    background: #87CEEB;
    display: grid;
    place-items: center;
  }
  #game {
    position: relative;
    width: var(--w);
    height: var(--h);
    background: linear-gradient(#bde0fe, #a4d4ff);
    overflow: hidden;
    border: 2px solid #000;
    border-radius: 8px;
  }
  #score {
    position: absolute;
    top: 8px;
    left: 12px;
    z-index: 10;
    font-weight: 700;
    font-size: 20px;
    color: #000;
    text-shadow: 0 1px 0 #fff7;
  }
  .player {
    position: absolute;
    width: 50px;
    height: 60px;
    background: #e63946;
    border-radius: 6px;
  }
  .platform {
    position: absolute;
    width: 120px;
    height: 22px;
    background: #2a9d8f;
    border-radius: 8px;
  }
  .floor { background: #2a9d8f; }
  #overlay {
    position: absolute;
    inset: 0;
    display: none;
    align-items: center;
    justify-content: center;
    background: #0008;
    color: #fff;
    z-index: 20;
  }
</style>
</head>
<body>
  <div id="game">
    <div id="score">Score: 0</div>
    <div id="overlay"><div>
      <h1>Game Over</h1>
      <p>Press R to restart</p>
    </div></div>
    <div id="player" class="player"></div>
  </div>

<script>
(() => {
  const game = document.getElementById('game');
  const playerEl = document.getElementById('player');
  const scoreEl = document.getElementById('score');
  const overlay = document.getElementById('overlay');

  const GAME_W = 480, GAME_H = 854;
  const P_W = 50, P_H = 60;
  const PLAT_W = 120, PLAT_H = 22;

  const GRAV = -0.45;
  const JUMP_V = 14.5;
  const MOVE_SPEED = 4.2;
  const AIR_CONTROL = 1.0;

  const THEO_MAX_H = (JUMP_V * JUMP_V) / (2 * Math.abs(GRAV));

  const START_V_GAP = 120;
  const START_H_GAP = 140;
  const MAX_V_GAP_CAP = Math.min(200, THEO_MAX_H * 0.85);
  const MAX_H_GAP_CAP = 180;
  const DIFF_EVERY = 10;
  const V_GAP_STEP = 6;
  const H_GAP_STEP = 6;

  const HALF_Y = GAME_H / 2;
  const BASE_SCROLL_SPEED = 1.6;
  const SCROLL_SPEED_STEP = 0.06;

  let px, py, vx, vy;
  let onGround;
  let cameraY;
  let scrollStarted;
  let autoScrollSpeed;
  let score;
  let platforms = [];
  let spawnCount = 0;
  let maxVGap = START_V_GAP;
  let maxHGap = START_H_GAP;
  let running = true;

  const keys = { left: false, right: false, jump: false };

  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
  function randRange(a, b) { return a + Math.random() * (b - a); }

  function makePlatform(x, y, isFloor = false) {
    const el = document.createElement('div');
    el.className = 'platform' + (isFloor ? ' floor' : '');
    el.style.width = PLAT_W + 'px';
    el.style.height = PLAT_H + 'px';
    game.appendChild(el);
    const plat = { x, y, el, isFloor };
    platforms.push(plat);
    return plat;
  }

  function setPlatformScreenPos(plat) {
    plat.el.style.left = plat.x + 'px';
    plat.el.style.bottom = (plat.y - cameraY) + 'px';
  }

  function setPlayerScreenPos() {
    playerEl.style.left = px + 'px';
    playerEl.style.bottom = (py - cameraY) + 'px';
  }

  function hud() { scoreEl.textContent = 'Score: ' + score; }

  function reset() {
    px = (GAME_W - P_W) / 2;
    py = 30;
    vx = 0; vy = 0;
    onGround = true;
    cameraY = 0;
    scrollStarted = false;
    autoScrollSpeed = 0;
    score = 0;
    spawnCount = 0;
    maxVGap = START_V_GAP;
    maxHGap = START_H_GAP;
    hud();
    overlay.style.display = 'none';
    running = true;

    platforms.forEach(p => p.el.remove());
    platforms = [];

    makePlatform((GAME_W - PLAT_W) / 2, 8, true);
    let y = 100;
    for (let i = 0; i < 7; i++) {
      const x = randRange(20, GAME_W - PLAT_W - 20);
      makePlatform(x, y);
      y += START_V_GAP;
    }
    platforms.forEach(setPlatformScreenPos);
    setPlayerScreenPos();
  }

  function spawnNextPlatform() {
    let highest = platforms.reduce((m, p) => Math.max(m, p.y), -Infinity);
    const minV = Math.min(100, maxVGap - 40);
    const vGap = randRange(minV, maxVGap);
    const newY = highest + vGap;

    const last = platforms.filter(p => !p.isFloor).slice(-1)[0] || { x: (GAME_W - PLAT_W) / 2 };
    let newX = last.x + randRange(-maxHGap, maxHGap);
    newX = clamp(newX, 10, GAME_W - PLAT_W - 10);

    const p = makePlatform(newX, newY);
    setPlatformScreenPos(p);

    score++;
    hud();

    spawnCount++;
    if (spawnCount % DIFF_EVERY === 0) {
      maxVGap = Math.min(MAX_V_GAP_CAP, maxVGap + V_GAP_STEP);
      maxHGap = Math.min(MAX_H_GAP_CAP, maxHGap + H_GAP_STEP);
      if (scrollStarted) autoScrollSpeed += SCROLL_SPEED_STEP;
    }
    return newY; // fixed: return the new highest
  }

  addEventListener('keydown', e => {
    if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = true;
    if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = true;
    if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') keys.jump = true;
    if (!running && e.code === 'KeyR') { reset(); }
  });
  addEventListener('keyup', e => {
    if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = false;
    if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = false;
    if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') keys.jump = false;
  });

  function frame() {
    if (!running) return;
    requestAnimationFrame(frame);

    const prevY = py;
    let targetVX = 0;
    if (keys.left) targetVX = -MOVE_SPEED;
    if (keys.right) targetVX =  MOVE_SPEED;
    vx = targetVX * (onGround ? 1 : AIR_CONTROL);
    px = clamp(px + vx, 0, GAME_W - P_W);

    if (keys.jump && onGround) {
      vy = JUMP_V;
      onGround = false;
    }

    vy += GRAV;
    py += vy;

    if (!scrollStarted && (py - cameraY) >= HALF_Y) {
      scrollStarted = true;
      autoScrollSpeed = BASE_SCROLL_SPEED;
    }

    if (scrollStarted) {
      cameraY += autoScrollSpeed;
      if ((py - cameraY) < 0 - P_H * 0.25) {
        gameOver();
        return;
      }
    } else {
      const floor = platforms.find(p => p.isFloor);
      const floorTop = floor.y + PLAT_H;
      if (py < floorTop) {
        py = floorTop;
        vy = 0;
        onGround = true;
      }
    }

    onGround = false;
    if (vy <= 0) {
      for (let i = 0; i < platforms.length; i++) {
        const p = platforms[i];
        const top = p.y + PLAT_H;
        const overlapX = (px + P_W > p.x) && (px < p.x + PLAT_W);
        const crossing = (prevY + P_H >= top) && (py + P_H <= top);
        if ((overlapX && crossing) && (!p.isFloor || !scrollStarted)) {
          py = top - P_H;
          vy = 0;
          onGround = true;
          break;
        }
      }
    }

    platforms = platforms.filter(p => {
      const onScreen = (p.y - cameraY) > -PLAT_H - 50;
      if (!onScreen) p.el.remove();
      return onScreen;
    });

    let highestY = platforms.reduce((m, p) => Math.max(m, p.y), -Infinity);
    let spawnedThisFrame = 0;
    const MAX_SPAWN_PER_FRAME = 4;
    while (highestY - cameraY < GAME_H * 1.5 && spawnedThisFrame < MAX_SPAWN_PER_FRAME) {
      highestY = spawnNextPlatform();
      spawnedThisFrame++;
    }

    setPlayerScreenPos();
    platforms.forEach(setPlatformScreenPos);
  }

  function gameOver() {
    running = false;
    overlay.style.display = 'flex';
  }

  reset();
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
