<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Endless Vertical Jump Game - Adjusted Assets</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background-color: #f0f0f0;
    }

    #game {
      position: relative;
      width: 400px;
      height: 600px;
      background-color: #87CEEB;
      overflow: hidden;
      border: 1px solid black;
    }

    #character {
      position: absolute;
      width: 100px;
      height: 100px;
      left: 190px;
      bottom: 0px;
      z-index: 10;
    }

    #character img {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    .platform {
      position: absolute;
      width: 250px; /* Reduced for better proportion */
      height: 83px; /* Adjusted for 3:1 aspect ratio (600x200px image) */
      background-size: contain; /* Preserve aspect ratio */
      background-repeat: no-repeat;
      background-position: center;
      z-index: 5;
    }

    #game-over {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 24px;
      font-family: Arial, sans-serif;
      color: white;
      text-align: center;
      background-color: rgba(0, 0, 0, 0.7);
      padding: 20px;
      z-index: 20;
      display: none;
    }

    #score {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 20px;
      font-family: Arial, sans-serif;
      color: black;
      z-index: 15;
    }
  </style>
</head>
<body>
  <div id="game">
    <div id="character">
      <!-- Character image (Seb Front 300.png) -->
      <img src="https://raw.githubusercontent.com/beuxlevi/jump-game-assets/main/Seb%20Front%20300.png" alt="Character">
    </div>
    <div id="game-over">Game Over<br>Press R to Restart</div>
    <div id="score">Score: 0</div>
  </div>

  <script>
    // Initial platform setup
    function createInitialPlatform(bottom, left, moving = false, icy = false, slow = false) {
      const platform = document.createElement('div');
      platform.className = 'platform';
      platform.style.bottom = bottom + 'px';
      platform.style.left = left + 'px';
      platform.style.backgroundImage = slow ? 'url(https://raw.githubusercontent.com/beuxlevi/jump-game-assets/main/Rock%20platform%20600.png)' : (icy ? 'url(https://raw.githubusercontent.com/beuxlevi/jump-game-assets/main/Ice%20platform%20600.png)' : 'url(https://raw.githubusercontent.com/beuxlevi/jump-game-assets/main/Grass%20platform%20600.png)');
      document.getElementById('game').appendChild(platform);
      const speed = moving ? (Math.random() * 1 + 0.5) * (Math.random() < 0.5 ? 1 : -1) : 0; // Initial 0.5-1.5
      return { bottom, left, width: 250, height: 83, element: platform, passed: false, moving, speed, icy, slow }; // Updated width and height
    }

    let platforms = [
      createInitialPlatform(50, 75),
      createInitialPlatform(150, 25),
      createInitialPlatform(250, 75),
      createInitialPlatform(350, 25),
      createInitialPlatform(450, 75),
      createInitialPlatform(550, 25)
    ];

    // Game variables
    let characterX = 190;
    let characterY = 0;
    let velocityX = 0;
    let velocityY = 0;
    let gravity = -0.5;
    const baseJumpStrength = 12;
    const maxJumpStrength = 16;
    const maxMoveSpeed = 4.5;
    const slowMaxMoveSpeed = 2.5;
    const acceleration = 0.15;
    const slowAcceleration = 0.08;
    const greenDeceleration = 1.0;
    const blueSlide = 0.05;
    let lastDirection = 0;
    let onGround = false;
    let onMovingPlatform = null;
    let platformOffsetX = 0;
    const gameWidth = 400;
    const gameHeight = 600;
    const charWidth = 100;
    const charHeight = 100;
    let gameOver = false;
    let scrolling = false;
    let scrollPaused = false;
    const baseScrollSpeed = 0.5;
    let currentScrollSpeed = 0;
    const scrollThreshold = 200;
    const maxScrollSpeed = 2;
    const targetY = gameHeight * 0.75;
    const spawnThreshold = 600;
    let score = 0;
    let directionHoldStart = null;
    const maxHoldTime = 1000;

    // Difficulty settings
    const baseVerticalSpacing = 100;
    const verticalSpacingIncrease = 20;
    const baseMaxJumpDistance = 250;
    const horizontalDistanceIncrease = 25;

    // Track platforms
    let blueCountStage2 = 0;
    let blueCountStage3 = 0;
    let blueCountStage4 = 0;
    let brownCountStage3 = 0;
    let brownCountStage4 = 0;
    let consecutiveBlues = 0;
    let consecutiveBrowns = 0;

    // Key states
    let keys = { left: false, right: false, jump: false };

    // Get current stage based on score
    function getStage() {
      return Math.floor(score / 50);
    }

    // Generate a new platform
    function generatePlatform() {
      const stage = getStage();
      const highestPlatform = platforms[platforms.length - 1];
      const verticalSpacing = stage < 3 ? baseVerticalSpacing + stage * verticalSpacingIncrease : baseVerticalSpacing + 2 * verticalSpacingIncrease; // 120px at 150+
      const maxJumpDistance = baseMaxJumpDistance + stage * horizontalDistanceIncrease;
      const newBottom = highestPlatform.bottom + verticalSpacing;
      let newLeft, newWidth, moving, speed, icy, slow;

      if (score % 50 === 49) {
        newLeft = 0;
        newWidth = gameWidth;
        moving = false;
        speed = 0;
        icy = false;
        slow = false;
        consecutiveBlues = 0;
        consecutiveBrowns = 0;
      } else {
        const minLeft = Math.max(0, highestPlatform.left - maxJumpDistance + 250); // Adjusted for new platform width
        const maxLeft = Math.min(gameWidth - 250, highestPlatform.left + maxJumpDistance - 250); // Adjusted for new platform width
        newLeft = Math.floor(minLeft + Math.random() * (maxLeft - minLeft + 1));
        newWidth = 250;
        const movingChance = Math.min(0 + stage * 0.2, 0.8);
        moving = Math.random() < movingChance;

        // Set speed based on stage
        if (stage === 1) speed = moving ? (Math.random() * 1 + 0.5) * (Math.random() < 0.5 ? 1 : -1) : 0; // 50-100: 0.5-1.5
        else if (stage === 2) speed = moving ? (Math.random() * 1.5 + 0.5) * (Math.random() < 0.5 ? 1 : -1) : 0; // 100-150: 0.5-2
        else if (stage === 3) speed = moving ? (Math.random() * 2 + 0.5) * (Math.random() < 0.5 ? 1 : -1) : 0; // 150-200: 0.5-2.5
        else if (stage === 4) speed = moving ? (Math.random() * 2.5 + 0.5) * (Math.random() < 0.5 ? 1 : -1) : 0; // 200-250: 0.5-3
        else speed = moving ? (Math.random() * 2 + 1) * (Math.random() < 0.5 ? 1 : -1) : 0; // 250+: 1-3

        // Platform types
        if (stage === 2 && score >= 100 && score < 150) {
          if (blueCountStage2 < 5 && consecutiveBlues < 3 && (Math.random() < 0.33 || blueCountStage2 < 3)) {
            icy = true;
            slow = false;
            blueCountStage2++;
            consecutiveBlues++;
            consecutiveBrowns = 0;
          } else {
            icy = false;
            slow = false;
            consecutiveBlues = 0;
          }
        } else if (stage === 3 && score >= 150 && score < 200) {
          if (blueCountStage3 < 10 && consecutiveBlues < 3 && (Math.random() < 0.33 || blueCountStage3 < 5)) {
            icy = true;
            slow = false;
            blueCountStage3++;
            consecutiveBlues++;
            consecutiveBrowns = 0;
          } else if (brownCountStage3 < 5 && consecutiveBrowns < 3 && (Math.random() < 0.25 || brownCountStage3 < 3)) {
            icy = false;
            slow = true;
            brownCountStage3++;
            consecutiveBrowns++;
            consecutiveBlues = 0;
          } else {
            icy = false;
            slow = false;
            consecutiveBlues = 0;
            consecutiveBrowns = 0;
          }
        } else if (stage === 4 && score >= 200 && score < 250) {
          if (blueCountStage4 < 15 && consecutiveBlues < 3 && (Math.random() < 0.5 || blueCountStage4 < 7)) {
            icy = true;
            slow = false;
            blueCountStage4++;
            consecutiveBlues++;
            consecutiveBrowns = 0;
          } else if (brownCountStage4 < 7 && consecutiveBrowns < 3 && (Math.random() < 0.35 || brownCountStage4 < 4)) {
            icy = false;
            slow = true;
            brownCountStage4++;
            consecutiveBrowns++;
            consecutiveBlues = 0;
          } else {
            icy = false;
            slow = false;
            consecutiveBlues = 0;
            consecutiveBrowns = 0;
          }
        } else {
          icy = (score >= 100 && consecutiveBlues < 3 && Math.random() < 0.1);
          slow = (score >= 150 && !icy && consecutiveBrowns < 3 && Math.random() < 0.1);
          consecutiveBlues = icy ? consecutiveBlues + 1 : 0;
          consecutiveBrowns = slow ? consecutiveBrowns + 1 : 0;
        }
      }

      const newPlatform = document.createElement('div');
      newPlatform.className = 'platform';
      newPlatform.style.bottom = newBottom + 'px';
      newPlatform.style.left = newLeft + 'px';
      newPlatform.style.width = newWidth + 'px';
      newPlatform.style.backgroundImage = slow ? 'url(https://raw.githubusercontent.com/beuxlevi/jump-game-assets/main/Rock%20platform%20600.png)' : (icy ? 'url(https://raw.githubusercontent.com/beuxlevi/jump-game-assets/main/Ice%20platform%20600.png)' : 'url(https://raw.githubusercontent.com/beuxlevi/jump-game-assets/main/Grass%20platform%20600.png)');
      document.getElementById('game').appendChild(newPlatform);
      return { bottom: newBottom, left: newLeft, width: newWidth, height: 83, element: newPlatform, passed: false, moving, speed, icy, slow };
    }

    // Update platforms and score
    function updatePlatforms() {
      if (gameOver) return;

      if (characterY > scrollThreshold) scrolling = true;

      if (scrolling && !gameOver && !scrollPaused) {
        currentScrollSpeed = baseScrollSpeed;
        if (characterY > targetY) {
          const excess = characterY - targetY;
          currentScrollSpeed = Math.min(baseScrollSpeed + excess * 0.05, maxScrollSpeed);
        }

        platforms.forEach(p => {
          p.bottom -= currentScrollSpeed;
          if (p.moving) {
            p.left += p.speed;
            if (p.left <= 0) {
              p.left = 0;
              p.speed = -p.speed;
            } else if (p.left >= gameWidth - p.width) {
              p.left = gameWidth - p.width;
              p.speed = -p.speed;
            }
            p.element.style.left = p.left + 'px';
          }
          p.element.style.bottom = p.bottom + 'px';
        });
      }

      platforms.forEach(p => {
        const platformTop = p.bottom + p.height;
        if (characterY > platformTop && !p.passed) {
          score += 1;
          p.passed = true;
          document.getElementById('score').textContent = `Score: ${score}`;
        }
      });

      const lowestPlatform = platforms[0];
      if (lowestPlatform.bottom < -lowestPlatform.height) {
        lowestPlatform.element.remove();
        platforms.shift();
      }

      const highestPlatform = platforms[platforms.length - 1];
      if (highestPlatform.bottom < spawnThreshold && !scrollPaused) {
        platforms.push(generatePlatform());
      }
    }

    // Game loop
    function update() {
      if (gameOver) return;

      let prevY = characterY;

      if (keys.jump && onGround) {
        let jumpStrength = baseJumpStrength;
        if (directionHoldStart !== null) {
          const holdTime = Date.now() - directionHoldStart;
          const holdFraction = Math.min(holdTime / maxHoldTime, 1);
          jumpStrength = baseJumpStrength + (maxJumpStrength - baseJumpStrength) * holdFraction;
        }
        velocityY = jumpStrength;
        onGround = false;
        onMovingPlatform = null;
        platformOffsetX = 0;
        keys.jump = false;
        directionHoldStart = null;
        if (scrollPaused) scrollPaused = false;
      }

      // Apply gravity only if not on the ground
      if (!onGround) {
        velocityY += gravity;
        if (Math.abs(velocityY) < 0.1) velocityY = 0; // Threshold to prevent minor oscillations
        characterY += velocityY;
      }

      if (keys.left && !keys.right) lastDirection = -1;
      else if (keys.right && !keys.left) lastDirection = 1;

      const currentMaxMoveSpeed = (onMovingPlatform && onMovingPlatform.slow) ? slowMaxMoveSpeed : maxMoveSpeed;
      const currentAcceleration = (onMovingPlatform && onMovingPlatform.slow) ? slowAcceleration : acceleration;

      if (keys.left && !keys.right) {
        velocityX -= currentAcceleration;
        if (velocityX < -currentMaxMoveSpeed) velocityX = -currentMaxMoveSpeed;
      } else if (keys.right && !keys.left) {
        velocityX += currentAcceleration;
        if (velocityX > currentMaxMoveSpeed) velocityX = currentMaxMoveSpeed;
      } else {
        if (onMovingPlatform && onMovingPlatform.icy) {
          if (velocityX > 0) {
            velocityX -= blueSlide;
            if (velocityX < 0) velocityX = 0;
          } else if (velocityX < 0) {
            velocityX += blueSlide;
            if (velocityX > 0) velocityX = 0;
          }
        } else {
          velocityX = 0;
        }
      }

      updatePlatforms();

      if (onGround && onMovingPlatform) {
        if (!keys.left && !keys.right && (!onMovingPlatform.icy || velocityX === 0)) {
          characterX = onMovingPlatform.left + platformOffsetX;
        } else {
          characterX += onMovingPlatform.speed;
          characterX += velocityX;
          if (onMovingPlatform.icy) {
            if (characterX < onMovingPlatform.left) characterX = onMovingPlatform.left;
            if (characterX > onMovingPlatform.left + onMovingPlatform.width - charWidth) {
              characterX = onMovingPlatform.left + onMovingPlatform.width - charWidth;
            }
          }
          platformOffsetX = characterX - onMovingPlatform.left;
        }
      } else {
        characterX += velocityX;
      }

      if (characterX < 0) characterX = 0;
      if (characterX > gameWidth - charWidth) characterX = gameWidth - charWidth;

      onGround = false;

      if (characterY <= 0) {
        characterY = 0;
        velocityY = 0;
        onGround = true;
        onMovingPlatform = null;
        platformOffsetX = 0;
        if (scrolling && !scrollPaused) {
          gameOver = true;
          document.getElementById('game-over').style.display = 'block';
        }
      }

      for (let platform of platforms) {
        let platformTop = platform.bottom + platform.height;
        let platformLeft = platform.left;
        let platformRight = platform.left + platform.width;

        let charRight = characterX + charWidth;
        let charTop = characterY + charHeight;

        let overlapsX = characterX < platformRight && charRight > platformLeft;

        if (
          overlapsX &&
          velocityY <= 0 &&
          prevY >= platformTop &&
          characterY < platformTop + 5 // Allow a small buffer for landing
        ) {
          characterY = platformTop - 15; // Adjusted offset to align feet
          velocityY = 0;
          onGround = true;
          // Maintain character on platform if already on ground
          if (onGround && characterY + charHeight > platformTop) {
            characterY = platformTop - 15;
          }
          if (platform.moving) {
            if (!onMovingPlatform) {
              platformOffsetX = characterX - platform.left;
            }
            onMovingPlatform = platform;
          } else {
            onMovingPlatform = null;
            platformOffsetX = 0;
          }
          if (score % 50 === 0 && platform.width === gameWidth) {
            scrollPaused = true;
          }
          break;
        }
      }

      if (characterY < -charHeight && !scrollPaused) {
        gameOver = true;
        document.getElementById('game-over').style.display = 'block';
      }

      const character = document.getElementById('character');
      character.style.bottom = characterY + 'px';
      character.style.left = characterX + 'px';

      requestAnimationFrame(update);
    }

    // Keyboard controls
    document.addEventListener('keydown', function(event) {
      if (gameOver && event.code === 'KeyR') {
        resetGame();
        return;
      }

      if (
        (event.code === 'ArrowUp' || event.code === 'KeyW' || event.code === 'Space') &&
        !gameOver
      ) {
        event.preventDefault();
        keys.jump = true;
      }

      if (event.code === 'ArrowLeft' || event.code === 'KeyA') {
        if (!keys.left) directionHoldStart = Date.now();
        keys.left = true;
      }

      if (event.code === 'ArrowRight' || event.code === 'KeyD') {
        if (!keys.right) directionHoldStart = Date.now();
        keys.right = true;
      }
    });

    document.addEventListener('keyup', function(event) {
      if (event.code === 'ArrowLeft' || event.code === 'KeyA') {
        keys.left = false;
        if (!keys.right) directionHoldStart = null;
      }
      if (event.code === 'ArrowRight' || event.code === 'KeyD') {
        keys.right = false;
        if (!keys.left) directionHoldStart = null;
      }
    });

    // Reset game function
    function resetGame() {
      gameOver = false;
      characterX = 190;
      characterY = 0;
      velocityX = 0;
      velocityY = 0;
      onGround = true;
      onMovingPlatform = null;
      platformOffsetX = 0;
      scrolling = false;
      scrollPaused = false;
      currentScrollSpeed = 0;
      score = 0;
      directionHoldStart = null;
      blueCountStage2 = 0;
      blueCountStage3 = 0;
      blueCountStage4 = 0;
      brownCountStage3 = 0;
      brownCountStage4 = 0;
      consecutiveBlues = 0;
      consecutiveBrowns = 0;
      document.getElementById('score').textContent = `Score: ${score}`;
      document.getElementById('game-over').style.display = 'none';

      platforms.forEach(p => p.element.remove());
      platforms = [
        createInitialPlatform(50, 75),
        createInitialPlatform(150, 25),
        createInitialPlatform(250, 75),
        createInitialPlatform(350, 25),
        createInitialPlatform(450, 75),
        createInitialPlatform(550, 25)
      ];

      requestAnimationFrame(update);
    }

    // Start game loop
    requestAnimationFrame(update);
  </script>
</body>
</html>
