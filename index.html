<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tower Jump — Prototype</title>
  <style>
    html, body { height: 100%; margin: 0; background: #0f1220; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; color: #e5e7eb; }
    #ui { position: fixed; top: 12px; left: 12px; display: flex; gap: 8px; align-items: center; z-index: 5; }
    .pill { background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.14); padding: 6px 10px; border-radius: 999px; backdrop-filter: blur(6px); }
    #controls { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); display: none; gap: 14px; z-index: 5; }
    .btn { width: 70px; height: 70px; border-radius: 50%; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.08); backdrop-filter: blur(6px); color: #fff; font-weight: 700; font-size: 18px; display: grid; place-items: center; user-select: none; }
    canvas { display: block; width: 100vw; height: 100vh; }
    #overlay { position: fixed; inset: 0; display: none; place-items: center; background: linear-gradient(180deg, rgba(0,0,0,0.6), rgba(0,0,0,0.7)); z-index: 10; }
    #card { background: #12162a; border: 1px solid rgba(255,255,255,0.1); padding: 24px; border-radius: 16px; text-align: center; width: min(520px, 92vw); }
    #card h1 { margin: 0 0 6px326646; font-size: 24px; }
    #card p { margin: 4px 0; color: #cbd5e1; }
    #card .row { display: flex; justify-content: center; gap: 12px; margin-top: 12px; }
    #card button { padding: 10px 16px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.15); background: #1a2040; color: #fff; font-weight: 700; cursor: pointer; }
    a { color: #93c5fd; }
  </style>
</head>
<body>
  <div id="ui">
    <div class="pill" id="score">Score: 0</div>
    <div class="pill" id="best">Best: 0</div>
    <div class="pill">Move: ← → • A D</div>
    <div class="pill">Jump: Auto (bounce)</div>
    <div class="pill">Restart: R or click</div>
  </div>

  <div id="controls">
    <div class="btn" id="left">←</div>
    <div class="btn" id="right">→</div>
  </div>

  <div id="overlay">
    <div id="card">
      <h1>Game Over</h1>
      <p id="finalScore">You reached 0 m</p>
      <div class="row">
        <button id="restart">Restart (R)</button>
      </div>
      <p style="margin-top:12px; font-size:12px; opacity:.8;">Prototype build — HTML Canvas. © You.</p>
    </div>
  </div>

  <canvas id="c"></canvas>

  <script>
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const finalScoreEl = document.getElementById('finalScore');
    const restartBtn = document.getElementById('restart');

    const mobileControls = document.getElementById('controls');
    const leftBtn = document.getElementById('left');
    const rightBtn = document.getElementById('right');

    let W = 0, H = 0;
    function resize() {
      W = canvas.width = window.innerWidth * devicePixelRatio;
      H = canvas.height = window.innerHeight * devicePixelRatio;
      ctx.setTransform(1,0,0,1,0,0);
      ctx.scale(devicePixelRatio, devicePixelRatio);
      // Show mobile controls for narrow screens
      mobileControls.style.display = window.innerWidth < 820 ? 'flex' : 'none';
    }
    window.addEventListener('resize', resize);
    resize();

    const rand = (min, max) => Math.random() * (max - min) + min;
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

    const G = 2400; // gravity px/s^2
    const JUMP_V = -1050; // auto-bounce velocity
    const MOVE_ACCEL = 2600;
    const MOVE_DRAG = 0.0016;
    const MAX_SPEED_X = 480;

    const WORLD = {
      cameraY: 0, // top-left world y shown on screen
      highestGeneratedY: 0, // smallest y (most negative) generated so far
      startY: 0,
      best: 0,
      running: true,
    };

    const player = {
      x: 0, y: 0, w: 36, h: 44,
      vx: 0, vy: 0,
      color: '#d1fae5',
      lastBottom: 0,
    };

    const platforms = [];

    function reset() {
      platforms.length = 0;
      WORLD.cameraY = 0;
      WORLD.highestGeneratedY = 0;
      WORLD.startY = 0;
      WORLD.running = true;

      // Initialize player roughly mid-bottom
      player.x = window.innerWidth / 2 - player.w / 2;
      player.y = window.innerHeight - 140;
      player.vx = 0; player.vy = -600; // initial upward kick

      // Base platform
      addPlatform(window.innerWidth/2 - 120, window.innerHeight - 80, 240, 20, 'solid');

      // Generate upwards a bit
      WORLD.highestGeneratedY = window.innerHeight - 200;
      while (WORLD.highestGeneratedY > -2000) {
        generateNextBand();
      }

      overlay.style.display = 'none';
    }

    function addPlatform(x, y, w, h, type='solid', meta={}) {
      platforms.push({ x, y, w, h, type, t: Math.random()*Math.PI*2, ...meta });
    }

    function generateNextBand() {
      // Generate a vertical band of platforms above current highestGeneratedY
      const bandHeight = 400; // px
      const targetTop = WORLD.highestGeneratedY - bandHeight;
      const density = 5 + Math.floor(rand(0, 2));

      for (let i = 0; i < density; i++) {
        const y = rand(targetTop, WORLD.highestGeneratedY - 40);
        const w = rand(90, 180);
        const h = 18;
        const x = rand(24, window.innerWidth - w - 24);
        // chance for a moving platform higher up
        const depth = -y; // higher = deeper (more negative y)
        const movingChance = clamp((depth - 600) / 3000, 0, 0.35);
        const breakChance = clamp((depth - 1000) / 4500, 0, 0.25);

        const r = Math.random();
        if (r < movingChance) {
          const range = rand(50, 160);
          const speed = rand(40, 90);
          addPlatform(x, y, w, h, 'moving', { ox: x, range, speed });
        } else if (r < movingChance + breakChance) {
          addPlatform(x, y, w, h, 'break');
        } else {
          addPlatform(x, y, w, h, 'solid');
        }
      }

      WORLD.highestGeneratedY = targetTop;
    }

    // Input
    const keys = new Set();
    window.addEventListener('keydown', (e) => {
      keys.add(e.key);
      if (e.key === 'r' || e.key === 'R') reset();
    });
    window.addEventListener('keyup', (e) => keys.delete(e.key));

    let touchLeft = false, touchRight = false;
    leftBtn.addEventListener('touchstart', e => { e.preventDefault(); touchLeft = true; });
    leftBtn.addEventListener('touchend', e => { e.preventDefault(); touchLeft = false; });
    rightBtn.addEventListener('touchstart', e => { e.preventDefault(); touchRight = true; });
    rightBtn.addEventListener('touchend', e => { e.preventDefault(); touchRight = false; });

    canvas.addEventListener('click', () => { if (!WORLD.running) reset(); });
    restartBtn.addEventListener('click', reset);

    let last = performance.now();

    function step(ts) {
      const dt = Math.min(0.02, (ts - last) / 1000);
      last = ts;

      update(dt);
      draw();
      requestAnimationFrame(step);
    }

    function update(dt) {
      if (!WORLD.running) return;

      const left = keys.has('ArrowLeft') || keys.has('a') || touchLeft;
      const right = keys.has('ArrowRight') || keys.has('d') || touchRight;

      // Horizontal
      let ax = 0;
      if (left) ax -= MOVE_ACCEL;
      if (right) ax += MOVE_ACCEL;
      player.vx += ax * dt;
      // Drag
      player.vx -= player.vx * MOVE_DRAG;
      player.vx = clamp(player.vx, -MAX_SPEED_X, MAX_SPEED_X);

      // Vertical
      player.vy += G * dt;

      // Apply
      player.x += player.vx * dt;
      player.y += player.vy * dt;

      // Wrap / clamp horizontally
      if (player.x + player.w < 0) player.x = window.innerWidth - 1;
      if (player.x > window.innerWidth) player.x = -player.w + 1;

      // Platforms update (moving etc)
      for (const p of platforms) {
        if (p.type === 'moving') {
          p.t += dt;
          p.x = p.ox + Math.sin(p.t * p.speed / 30) * p.range;
        }
      }

      // Collision: only when falling and crossing from above
      const prevBottom = player.lastBottom;
      player.lastBottom = player.y + player.h;

      if (player.vy > 0) {
        for (const p of platforms) {
          const wasAbove = prevBottom <= p.y + 1;
          if (!wasAbove) continue; // ensure landing from above
          if (
            player.x < p.x + p.w &&
            player.x + player.w > p.x &&
            player.y + player.h > p.y &&
            player.y + player.h < p.y + p.h + 20 // small tolerance
          ) {
            // Land
            player.y = p.y - player.h;
            player.vy = JUMP_V; // auto-bounce jump
            if (p.type === 'break') p.type = 'gone';
          }
        }
      }

      // Remove broken platforms
      for (let i = platforms.length - 1; i >= 0; i--) {
        if (platforms[i].type === 'gone') platforms.splice(i, 1);
      }

      // Camera follows player upward (never moves down)
      const targetCam = Math.min(WORLD.cameraY, player.y - window.innerHeight * 0.45);
      WORLD.cameraY = targetCam;

      // Score (meters as pixels/100)
      const heightClimbed = Math.max(0, Math.floor((-(player.y - WORLD.startY)) / 100));
      scoreEl.textContent = `Score: ${heightClimbed}`;
      if (heightClimbed > WORLD.best) {
        WORLD.best = heightClimbed;
        bestEl.textContent = `Best: ${WORLD.best}`;
      }

      // Generate more platforms above as needed
      while (WORLD.highestGeneratedY > WORLD.cameraY - 1200) {
        generateNextBand();
      }

      // Cull platforms far below
      for (let i = platforms.length - 1; i >= 0; i--) {
        if (platforms[i].y - WORLD.cameraY > window.innerHeight + 400) platforms.splice(i, 1);
      }

      // Death: fell below screen bottom
      if (player.y - WORLD.cameraY > window.innerHeight + 120) {
        WORLD.running = false;
        finalScoreEl.textContent = `You reached ${WORLD.best} m`;
        overlay.style.display = 'grid';
      }
    }

    function drawBG() {
      // Gradient sky
      const g = ctx.createLinearGradient(0, 0, 0, window.innerHeight);
      g.addColorStop(0, '#0b1022');
      g.addColorStop(1, '#1a1f3f');
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);

      // Subtle parallax stripes
      ctx.globalAlpha = 0.10;
      const stripeH = 80;
      const offs = (WORLD.cameraY * 0.15) % stripeH;
      ctx.fillStyle = '#0f1430';
      for (let y = -stripeH; y < window.innerHeight + stripeH; y += stripeH) {
        ctx.fillRect(0, Math.floor(y + offs), window.innerWidth, stripeH * 0.5);
      }
      ctx.globalAlpha = 1;
    }

    function draw() {
      ctx.setTransform(1,0,0,1,0,0);
      drawBG();

      // World transform (camera)
      ctx.translate(0, -WORLD.cameraY);

      // Draw platforms
      for (const p of platforms) {
        if (p.type === 'gone') continue;
        // Style by type
        if (p.type === 'solid') ctx.fillStyle = '#7dd3fc';
        else if (p.type === 'moving') ctx.fillStyle = '#a78bfa';
        else if (p.type === 'break') ctx.fillStyle = '#fca5a5';
        else ctx.fillStyle = '#334155';

        // Soft shadow
        ctx.save();
        ctx.globalAlpha = 0.25;
        ctx.fillRect(p.x + 4, p.y + 6, p.w, p.h);
        ctx.restore();

        // Platform
        ctx.fillRect(p.x, p.y, p.w, p.h);
      }

      // Draw player
      ctx.save();
      // Shadow
      ctx.globalAlpha = 0.25;
      ctx.fillStyle = '#000';
      ctx.fillRect(player.x + 4, player.y + 8, player.w, player.h);
      ctx.restore();
      // Body
      ctx.fillStyle = player.color;
      ctx.fillRect(player.x, player.y, player.w, player.h);

      // Eyes (tiny)
      ctx.fillStyle = '#0f172a';
      ctx.fillRect(player.x + 10, player.y + 14, 4, 4);
      ctx.fillRect(player.x + 22, player.y + 14, 4, 4);
    }

    reset();
    requestAnimationFrame(step);
  </script>
</body>
</html>