<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Endless Jumper â€” Clean Core (Fixed)</title>
<style>
  :root {
    --w: 480px;  /* 16:9 portrait */
    --h: 854px;
  }
  html, body {
    height: 100%;
    margin: 0;
    background: #87CEEB;
    display: grid;
    place-items: center;
    font-family: system-ui, Arial, sans-serif;
  }
  #game {
    position: relative;
    width: var(--w);
    height: var(--h);
    background: linear-gradient(#bde0fe, #a4d4ff);
    overflow: hidden;
    border: 2px solid #000;
    border-radius: 10px;
  }
  #score {
    position: absolute;
    top: 8px;
    left: 12px;
    z-index: 10;
    font-weight: 700;
    font-size: 20px;
    color: #000;
    text-shadow: 0 1px 0 #fff7;
  }
  .player {
    position: absolute;
    width: 50px;
    height: 60px;
    background: #e63946;
    border-radius: 6px;
  }
  .platform {
    position: absolute;
    width: 120px;
    height: 22px;
    background: #2a9d8f;
    border-radius: 8px;
  }
  .floor { background: #2a9d8f; }
  #overlay {
    position: absolute;
    inset: 0;
    display: none;
    align-items: center;
    justify-content: center;
    background: #0008;
    color: #fff;
    z-index: 20;
    text-align: center;
  }
  #overlay .card {
    background: #111a;
    padding: 16px 20px;
    border-radius: 10px;
    border: 1px solid #fff3;
  }
</style>
</head>
<body>
  <div id="game">
    <div id="score">Score: 0</div>
    <div id="overlay"><div class="card">
      <h1>Game Over</h1>
      <p>Press R to restart</p>
    </div></div>
    <div id="player" class="player"></div>
  </div>

<script>
(() => {
  const game = document.getElementById('game');
  const playerEl = document.getElementById('player');
  const scoreEl = document.getElementById('score');
  const overlay = document.getElementById('overlay');

  // --- Dimensions ---
  const GAME_W = 480, GAME_H = 854;
  const P_W = 50, P_H = 60;
  const PLAT_W = 120, PLAT_H = 22;

  // --- Physics tuning ---
  // (Bottom-up coordinates; gravity is negative.)
  const GRAV = -0.45;
  const JUMP_V = 14.5;         // higher so gaps are reachable
  const MOVE_SPEED = 4.2;      // horizontal speed
  const AIR_CONTROL = 1.0;     // arcade feel (full air control)

  // Theoretical max jump height (for safe spacing caps)
  const THEO_MAX_H = (JUMP_V * JUMP_V) / (2 * Math.abs(GRAV)); // ~233px

  // --- Gap tuning (always jumpable; difficulty ramps slowly) ---
  const START_V_GAP = 120;
  const START_H_GAP = 140;
  const MAX_V_GAP_CAP = Math.min(200, THEO_MAX_H * 0.85); // <= ~198px
  const MAX_H_GAP_CAP = 180;

  // Increase difficulty every N spawns
  const DIFF_EVERY = 10;
  const V_GAP_STEP = 6;
  const H_GAP_STEP = 6;

  // --- Scrolling rules ---
  const HALF_Y = GAME_H / 2;          // trigger line
  const BASE_SCROLL_SPEED = 1.6;      // once started, never stops
  const SCROLL_SPEED_STEP = 0.06;     // ramps slightly as you go

  // --- Game state ---
  let px, py, vx, vy;                 // player pos (bottom-left), velocity
  let onGround;
  let cameraY;                        // world-to-screen offset
  let scrollStarted;                  // bottom safe until true
  let autoScrollSpeed;
  let score;
  let platforms = [];
  let spawnCount = 0;
  let maxVGap = START_V_GAP;
  let maxHGap = START_H_GAP;
  let running = true;

  const keys = { left: false, right: false, jump: false };

  // --- Helpers ---
  const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
  const randRange = (a,b) => a + Math.random() * (b - a);

  function makePlatform(x, y, isFloor = false) {
    const el = document.createElement('div');
    el.className = 'platform' + (isFloor ? ' floor' : '');
    el.style.width = PLAT_W + 'px';
    el.style.height = PLAT_H + 'px';
    game.appendChild(el);
    const plat = { x, y, el, isFloor };
    platforms.push(plat);
    return plat;
  }
  function setPlatformScreenPos(p) {
    p.el.style.left = p.x + 'px';
    p.el.style.bottom = (p.y - cameraY) + 'px';
  }
  function setPlayerScreenPos() {
    playerEl.style.left = px + 'px';
    playerEl.style.bottom = (py - cameraY) + 'px';
  }
  function hud() { scoreEl.textContent = 'Score: ' + score; }

  function reset() {
    // Player starts at bottom on a safe floor
    px = (GAME_W - P_W) / 2;
    py = 30;              // just above floor top
    vx = 0; vy = 0;
    onGround = true;

    cameraY = 0;
    scrollStarted = false;
    autoScrollSpeed = 0;
    score = 0;
    spawnCount = 0;
    maxVGap = START_V_GAP;
    maxHGap = START_H_GAP;
    hud();
    overlay.style.display = 'none';
    running = true;

    // Clear platforms
    platforms.forEach(p => p.el.remove());
    platforms = [];

    // Floor platform (safe until scroll starts)
    makePlatform((GAME_W - PLAT_W) / 2, 8, true);

    // Seed a column of reachable platforms
    let y = 100;
    for (let i = 0; i < 7; i++) {
      const x = randRange(20, GAME_W - PLAT_W - 20);
      makePlatform(x, y);
      y += START_V_GAP;
    }

    // Apply initial DOM positions
    platforms.forEach(setPlatformScreenPos);
    setPlayerScreenPos();
  }

  // Spawn the next platform within jumpable limits; return its Y
  function spawnNextPlatform() {
    const highest = platforms.reduce((m, p) => Math.max(m, p.y), -Infinity);

    // vertical gap: within safe range
    const minV = Math.min(100, maxVGap - 40);
    const vGap = randRange(minV, maxVGap);
    const newY = highest + vGap;

    // horizontal gap: near last spawned X
    const last = platforms.filter(p => !p.isFloor).slice(-1)[0] || { x: (GAME_W - PLAT_W) / 2 };
    let newX = last.x + randRange(-maxHGap, maxHGap);
    newX = clamp(newX, 10, GAME_W - PLAT_W - 10);

    const p = makePlatform(newX, newY);
    setPlatformScreenPos(p);

    // score per spawn (simple & reliable)
    score++; hud();

    // difficulty ramps softly
    spawnCount++;
    if (spawnCount % DIFF_EVERY === 0) {
      maxVGap = Math.min(MAX_V_GAP_CAP, maxVGap + V_GAP_STEP);
      maxHGap = Math.min(MAX_H_GAP_CAP, maxHGap + H_GAP_STEP);
      if (scrollStarted) autoScrollSpeed += SCROLL_SPEED_STEP;
    }
    return newY;
  }

  // --- Input ---
  addEventListener('keydown', e => {
    if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = true;
    if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = true;
    if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') keys.jump = true;
    if (!running && e.code === 'KeyR') reset();
  });
  addEventListener('keyup', e => {
    if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = false;
    if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = false;
    if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') keys.jump = false;
  });

  // --- Main loop ---
  function frame() {
    if (!running) return;
    requestAnimationFrame(frame);

    const prevBottom = py; // previous bottom (for edge-cross landing)

    // Horizontal movement (arcade: full air control)
    let targetVX = 0;
    if (keys.left)  targetVX = -MOVE_SPEED;
    if (keys.right) targetVX =  MOVE_SPEED;
    vx = targetVX * (onGround ? 1.0 : AIR_CONTROL);
    px = clamp(px + vx, 0, GAME_W - P_W);

    // Jump (only if grounded)
    if (keys.jump && onGround) {
      vy = JUMP_V;
      onGround = false;
    }

    // Gravity + vertical integration
    vy += GRAV;
    py += vy;

    // Start scrolling when player passes halfway (first time only)
    if (!scrollStarted && (py - cameraY) >= HALF_Y) {
      scrollStarted = true;
      autoScrollSpeed = BASE_SCROLL_SPEED; // never stops afterwards
    }

    // Bottom-of-screen handling:
    if (scrollStarted) {
      // Deadly bottom once scrolling
      if ((py - cameraY) < 0 - P_H * 0.25) {
        return gameOver();
      }
    } else {
      // Before scroll: floor is safe; clamp to floor
      const floor = platforms.find(p => p.isFloor);
      const floorTop = floor.y + PLAT_H;
      if (py <= floorTop) {
        py = floorTop;
        vy = 0;
        onGround = true;
      }
    }

    // One-way platform landing (falling from above). Use edge-cross check.
    onGround = onGround && !scrollStarted ? onGround : false; // keep floor-ground only pre-scroll
    if (vy <= 0) {
      for (const p of platforms) {
        const top = p.y + PLAT_H;
        const overlapX = (px + P_W > p.x) && (px < p.x + PLAT_W);
        const crossedTop = (prevBottom >= top) && (py <= top);
        // Land on normal platforms anytime; on floor only before scroll
        const canLandOnThis = !p.isFloor || !scrollStarted;
        if (overlapX && crossedTop && canLandOnThis) {
          py = top;
          vy = 0;
          onGround = true;
          break;
        }
      }
    }

    // Apply auto-scroll to camera (never stops once started)
    if (scrollStarted) {
      cameraY += autoScrollSpeed;
    }

    // Despawn platforms that are well below camera
    platforms = platforms.filter(p => {
      const onScreen = (p.y - cameraY) > -PLAT_H - 60;
      if (!onScreen) p.el.remove();
      return onScreen;
    });

    // Keep a pipeline of platforms ahead (limit spawns per frame)
    let highestY = platforms.reduce((m, p) => Math.max(m, p.y), -Infinity);
    let spawnedThisFrame = 0;
    const MAX_SPAWN_PER_FRAME = 4;
    while (highestY - cameraY < GAME_H * 1.5 && spawnedThisFrame < MAX_SPAWN_PER_FRAME) {
      highestY = spawnNextPlatform();   // update highestY each spawn
      spawnedThisFrame++;
    }

    // Write DOM positions
    setPlayerScreenPos();
    platforms.forEach(setPlatformScreenPos);
  }

  function gameOver() {
    running = false;
    overlay.style.display = 'flex';
  }

  reset();
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
