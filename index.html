<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tower Jump — Prototype (Assets wired)</title>
  <style>
    html, body { height: 100%; margin: 0; background: #0f1220; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; color: #e5e7eb; }
    #ui { position: fixed; top: 12px; left: 12px; display: flex; gap: 8px; align-items: center; z-index: 5; }
    .pill { background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.14); padding: 6px 10px; border-radius: 999px; backdrop-filter: blur(6px); }
    #controls { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); display: none; gap: 14px; z-index: 5; }
    .btn { width: 70px; height: 70px; border-radius: 50%; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.08); backdrop-filter: blur(6px); color: #fff; font-weight: 700; font-size: 18px; display: grid; place-items: center; user-select: none; }
    canvas { display: block; width: 100vw; height: 100vh; }
    #overlay { position: fixed; inset: 0; display: none; place-items: center; background: linear-gradient(180deg, rgba(0,0,0,0.6), rgba(0,0,0,0.7)); z-index: 10; }
    #card { background: #12162a; border: 1px solid rgba(255,255,255,0.1); padding: 24px; border-radius: 16px; text-align: center; width: min(520px, 92vw); }
    #card h1 { margin: 0 0 6px; font-size: 24px; }
    #card p { margin: 4px 0; color: #cbd5e1; }
    #card .row { display: flex; justify-content: center; gap: 12px; margin-top: 12px; }
    #card button { padding: 10px 16px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.15); background: #1a2040; color: #fff; font-weight: 700; cursor: pointer; }
    a { color: #93c5fd; }
  </style>
</head>
<body>
  <div id="ui">
    <div class="pill" id="score">Score: 0</div>
    <div class="pill" id="best">Best: 0</div>
    <div class="pill">Move: ← → • A D</div>
    <div class="pill">Jump: Auto (bounce)</div>
    <div class="pill">Restart: R or click</div>
  </div>

  <div id="controls">
    <div class="btn" id="left">←</div>
    <div class="btn" id="right">→</div>
  </div>

  <div id="overlay">
    <div id="card">
      <h1>Game Over</h1>
      <p id="finalScore">You reached 0 m</p>
      <div class="row">
        <button id="restart">Restart (R)</button>
      </div>
      <p style="margin-top:12px; font-size:12px; opacity:.8;">Prototype build — HTML Canvas. © You.</p>
    </div>
  </div>

  <canvas id="c"></canvas>

  <script>
    // === ASSETS from your GitHub repo (raw URLs; spaces are URL-encoded) ===
    const ASSETS = {
      player: 'https://raw.githubusercontent.com/beuxlevi/jump-game-assets/main/Seb%20Front%20300.png',
      platform_grass: 'https://raw.githubusercontent.com/beuxlevi/jump-game-assets/main/Grass%20platform%20300.png',
      platform_ice:   'https://raw.githubusercontent.com/beuxlevi/jump-game-assets/main/Ice%20platform%20300.png',
      platform_rock:  'https://raw.githubusercontent.com/beuxlevi/jump-game-assets/main/Rock%20platform%20300.png'
    };

    // Physics per platform surface
    const SURFACE = {
      grass: { label: 'Grass', friction: 1.0 },   // normal
      ice:   { label: 'Ice',   friction: 0.20 },  // slippy
      rock:  { label: 'Rock',  friction: 2.50 }   // sticky
    };

    // Loader
    function loadImage(src) {
      return new Promise((res, rej) => { const i = new Image(); i.onload = () => res(i); i.onerror = rej; i.src = src; });
    }

    const SPRITES = { player: null, grass: null, ice: null, rock: null };
    Promise.all([
      loadImage(ASSETS.player).then(img => SPRITES.player = img).catch(()=>{}),
      loadImage(ASSETS.platform_grass).then(img => SPRITES.grass = img).catch(()=>{}),
      loadImage(ASSETS.platform_ice).then(img => SPRITES.ice = img).catch(()=>{}),
      loadImage(ASSETS.platform_rock).then(img => SPRITES.rock = img).catch(()=>{})
    ]).then(()=>{ /* sprites ready (or some missing, we fallback) */ });

    // === Canvas + world setup ===
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const overlay = document.getElementById('overlay');
    const finalScoreEl = document.getElementById('finalScore');
    const restartBtn = document.getElementById('restart');

    const mobileControls = document.getElementById('controls');
    const leftBtn = document.getElementById('left');
    const rightBtn = document.getElementById('right');

    let W = 0, H = 0;
    function resize() {
      W = canvas.width = window.innerWidth * devicePixelRatio;
      H = canvas.height = window.innerHeight * devicePixelRatio;
      ctx.setTransform(1,0,0,1,0,0);
      ctx.scale(devicePixelRatio, devicePixelRatio);
      mobileControls.style.display = window.innerWidth < 820 ? 'flex' : 'none';
    }
    window.addEventListener('resize', resize);
    resize();

    const rand = (min, max) => Math.random() * (max - min) + min;

    const G = 2400; // gravity px/s^2
    const JUMP_V = -1050; // auto-bounce velocity
    const MOVE_ACCEL = 2600;
    const AIR_DRAG = 0.0016; // base air drag factor
    const MAX_SPEED_X = 520;

    const WORLD = { cameraY: 0, highestGeneratedY: 0, startY: 0, best: 0, running: true };

    const player = { x: 0, y: 0, w: 40, h: 48, vx: 0, vy: 0, lastBottom: 0, grounded: false, groundSurface: 'grass' };

    const platforms = [];

    function reset() {
      platforms.length = 0;
      WORLD.cameraY = 0; WORLD.highestGeneratedY = 0; WORLD.startY = 0; WORLD.running = true;

      player.x = window.innerWidth / 2 - player.w / 2;
      player.y = window.innerHeight - 140;
      player.vx = 0; player.vy = -600; player.grounded = false;

      addPlatform(window.innerWidth/2 - 120, window.innerHeight - 80, 240, 24, 'grass'); // base grass

      WORLD.highestGeneratedY = window.innerHeight - 200;
      while (WORLD.highestGeneratedY > -2000) generateNextBand();

      overlay.style.display = 'none';
    }

    function addPlatform(x, y, w, h, surface = 'grass', meta = {}) {
      platforms.push({ x, y, w, h, surface, t: Math.random()*Math.PI*2, moving: !!meta.moving, ox: x, range: meta.range||0, speed: meta.speed||0, breakable: !!meta.breakable });
    }

    function pickSurface(depth) {
      // Simple weighted mix; tweak if you want more/less of each as you climb
      const r = Math.random();
      if (r < 0.55) return 'grass';           // 55%
      if (r < 0.80) return 'ice';             // 25%
      return 'rock';                           // 20%
    }

    function generateNextBand() {
      const bandHeight = 420;
      const targetTop = WORLD.highestGeneratedY - bandHeight;
      const density = 6 + Math.floor(Math.random()*2);

      for (let i = 0; i < density; i++) {
        const y = rand(targetTop, WORLD.highestGeneratedY - 50);
        const w = rand(120, 220);
        const h = 26;
        const x = rand(24, window.innerWidth - w - 24);
        const depth = -y;
        const movingChance = Math.min(Math.max((depth - 800)/3000, 0), 0.35);
        const breakChance  = Math.min(Math.max((depth - 1200)/4500, 0), 0.25);
        const surface = pickSurface(depth);

        const r = Math.random();
        if (r < movingChance) {
          addPlatform(x, y, w, h, surface, { moving: true, range: rand(60, 160), speed: rand(40, 90) });
        } else if (r < movingChance + breakChance) {
          addPlatform(x, y, w, h, surface, { breakable: true });
        } else {
          addPlatform(x, y, w, h, surface);
        }
      }

      WORLD.highestGeneratedY = targetTop;
    }

    // Input
    const keys = new Set();
    window.addEventListener('keydown', (e) => { keys.add(e.key); if (e.key === 'r' || e.key === 'R') reset(); });
    window.addEventListener('keyup', (e) => keys.delete(e.key));

    let touchLeft = false, touchRight = false;
    leftBtn?.addEventListener('touchstart', e => { e.preventDefault(); touchLeft = true; });
    leftBtn?.addEventListener('touchend', e => { e.preventDefault(); touchLeft = false; });
    rightBtn?.addEventListener('touchstart', e => { e.preventDefault(); touchRight = true; });
    rightBtn?.addEventListener('touchend', e => { e.preventDefault(); touchRight = false; });

    canvas.addEventListener('click', () => { if (!WORLD.running) reset(); });
    restartBtn.addEventListener('click', reset);

    let last = performance.now();
    requestAnimationFrame(function step(ts){
      const dt = Math.min(0.02, (ts - last) / 1000); last = ts;
      update(dt); draw(); requestAnimationFrame(step);
    });

    function update(dt) {
      if (!WORLD.running) return;

      const left = keys.has('ArrowLeft') || keys.has('a') || touchLeft;
      const right = keys.has('ArrowRight') || keys.has('d') || touchRight;

      // Horizontal accel
      let ax = 0; if (left) ax -= MOVE_ACCEL; if (right) ax += MOVE_ACCEL; player.vx += ax * dt;

      // Air drag always
      player.vx -= player.vx * AIR_DRAG;

      // Extra ground friction by surface when grounded
      if (player.grounded) {
        const mu = SURFACE[player.groundSurface]?.friction ?? 1.0; // coefficient
        // simple proportional friction; bigger mu = stronger slowdown (sticky)
        player.vx -= player.vx * mu * 6 * dt; // tune 6 for feel
      }

      player.vx = Math.max(-MAX_SPEED_X, Math.min(MAX_SPEED_X, player.vx));

      // Vertical
      player.vy += G * dt;

      // Apply
      player.x += player.vx * dt;
      player.y += player.vy * dt;

      // Horizontal wrap
      if (player.x + player.w < 0) player.x = window.innerWidth - 1;
      if (player.x > window.innerWidth) player.x = -player.w + 1;

      // Move platforms
      for (const p of platforms) {
        if (p.moving) { p.t += dt; p.x = p.ox + Math.sin(p.t * p.speed / 30) * p.range; }
      }

      // Collisions
      const prevBottom = player.lastBottom; player.lastBottom = player.y + player.h; let justLanded = false;
      if (player.vy > 0) {
        for (const p of platforms) {
          if (p.breakable && p._gone) continue;
          const wasAbove = prevBottom <= p.y + 1;
          if (!wasAbove) continue;
          if (player.x < p.x + p.w && player.x + player.w > p.x && player.y + player.h > p.y && player.y + player.h < p.y + p.h + 20) {
            // Land
            player.y = p.y - player.h; player.vy = JUMP_V; justLanded = true; player.grounded = true; player.groundSurface = p.surface;
            if (p.breakable) p._gone = true; // mark for removal after bounce
          }
        }
      }
      if (!justLanded) player.grounded = false;

      // Remove broken platforms
      for (let i = platforms.length - 1; i >= 0; i--) if (platforms[i]._gone) platforms.splice(i, 1);

      // Camera (locks to highest point reached)
      const targetCam = Math.min(WORLD.cameraY, player.y - window.innerHeight * 0.45);
      WORLD.cameraY = targetCam;

      // Score
      const heightClimbed = Math.max(0, Math.floor((-(player.y - WORLD.startY)) / 100));
      scoreEl.textContent = `Score: ${heightClimbed}`;
      if (heightClimbed > WORLD.best) { WORLD.best = heightClimbed; bestEl.textContent = `Best: ${WORLD.best}`; }

      // Generate & cull
      while (WORLD.highestGeneratedY > WORLD.cameraY - 1200) generateNextBand();
      for (let i = platforms.length - 1; i >= 0; i--) if (platforms[i].y - WORLD.cameraY > window.innerHeight + 400) platforms.splice(i, 1);

      // Death
      if (player.y - WORLD.cameraY > window.innerHeight + 120) {
        WORLD.running = false; finalScoreEl.textContent = `You reached ${WORLD.best} m`; overlay.style.display = 'grid';
      }
    }

    function drawBG() {
      // Gradient sky fallback
      const g = ctx.createLinearGradient(0, 0, 0, window.innerHeight);
      g.addColorStop(0, '#0b1022'); g.addColorStop(1, '#1a1f3f');
      ctx.fillStyle = g; ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);
      // Parallax stripes
      ctx.globalAlpha = 0.10; const stripeH = 80; const offs = (WORLD.cameraY * 0.15) % stripeH; ctx.fillStyle = '#0f1430';
      for (let y = -stripeH; y < window.innerHeight + stripeH; y += stripeH) ctx.fillRect(0, Math.floor(y + offs), window.innerWidth, stripeH * 0.5);
      ctx.globalAlpha = 1;
    }

    function draw() {
      ctx.setTransform(1,0,0,1,0,0); drawBG();
      ctx.translate(0, -WORLD.cameraY);

      // Platforms
      for (const p of platforms) {
        const img = SPRITES[p.surface];
        if (img) {
          // soft shadow
          ctx.save(); ctx.globalAlpha = 0.25; ctx.drawImage(img, p.x + 4, p.y + 6, p.w, p.h); ctx.restore();
          ctx.drawImage(img, p.x, p.y, p.w, p.h);
        } else {
          // fallback colours
          const col = p.surface === 'grass' ? '#7dd3fc' : p.surface === 'ice' ? '#a5f3fc' : '#fca5a5';
          ctx.save(); ctx.globalAlpha = 0.25; ctx.fillStyle = '#000'; ctx.fillRect(p.x + 4, p.y + 6, p.w, p.h); ctx.restore();
          ctx.fillStyle = col; ctx.fillRect(p.x, p.y, p.w, p.h);
        }
      }

      // Player
      if (SPRITES.player) {
        ctx.save(); ctx.globalAlpha = 0.25; ctx.drawImage(SPRITES.player, player.x + 4, player.y + 8, player.w, player.h); ctx.restore();
        ctx.drawImage(SPRITES.player, player.x, player.y, player.w, player.h);
      } else {
        ctx.save(); ctx.globalAlpha = 0.25; ctx.fillStyle = '#000'; ctx.fillRect(player.x + 4, player.y + 8, player.w, player.h); ctx.restore();
        ctx.fillStyle = '#d1fae5'; ctx.fillRect(player.x, player.y, player.w, player.h);
      }
    }

    reset();
  </script>
</body>
</html>
